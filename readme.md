## 动态代理:  

_________________________________________

1. 特点:字节码随用随创建,随用随加载  

2. 作用:不修改源码的基础上对方法增强   

3. 分类:  
 3.1 基于接口的动态代理  
 3.2 基于子类的动态代理
 
_________________________________________

### `cn.imust.proxy` 包下为基于接口的动态代理(具体使用在Client类中)  
* 涉及的类: `Proxy`
* 提供者: `JDK官方`
* 如何创建代理对象:
    * 使用 `Proxy` 中的 `newProxyInstance` 方法
* 创建代理对象要求:
    * 被代理类最少实现一个接口,如果没有则不能使用  
    
* `newProxyInstance` 方法的参数
    * `ClassLoader` :类加载器 _固定写法_
        * 用于加载代理对象字节码的.和被代理对象使用的是相同的类加载器(写的是被代理对象的类加载器)
    * `Class[]` :字节码数字 _固定写法_
        * 用于让代理对象和被代理对象有相同的方法.(即实现相同的接口,使之有相同的方法) 写的是被代理对象所实现的接口
    * `InvocationHandler` :用于提供增强的代码
        * 让我们写如何代理,一般都是写一个 `该接口` 的实现类,通常情况下都是匿名内部类(不是必须的)
        * 此接口的实现类都是谁用谁写
        * `InvocationHandler接口的实现类`只有一个 `invoke` 方法
            > `invoke` 方法  (和被代理对象拥有相同的返回值)
            >> 作用 : 执行被代理对象的任何接口方法都会执行该方法  
            >>> 方法参数的含义:  
            `proxy` : 代理对象的引用  
            `method` : 当前执行的方法  
            `args` : 当前执行的方法所需的参数
           
_________________________________________

### `cn.imust.cglib` 包下为基于子类的动态代理(具体使用在Client类中)

* 涉及的类: `Enhancer`
* 提供者: `第三方cglib库`
* 如何创建代理对象:
    * 使用 `Enhancer` 中的 `create` 方法
* 创建代理对象要求:
    * 被代理类不能是最终类  
    
* `newProxyInstance` 方法的参数
    * `Class` :字节码 _固定写法_
        * 用于指定被代理对象的字节码
    * `Callback` :用于提供增强的代码
        * 让我们写如何代理,
        * 此接口的实现类都是谁用谁写
        * 一般写的都是 `该接口的子接口` 的实现类 : MethodInterceptor 通常情况下都是匿名内部类(不是必须的)
        * `MethodInterceptor接口的实现类`只有一个 `intercept` 方法
            > `intercept` 方法  (和被代理对象拥有相同的返回值)
            >> 作用 : 执行被代理对象的任何接口方法都会经过该方法  
            >>> 方法参数的含义:  
            `proxy` : 代理对象的引用  
            `method` : 当前执行的方法  
            `args` : 当前执行的方法所需的参数
            `methodProxy` : 当前执行方法的代理对象